<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Face Detection and Tracking - Microbit + Arduino (L/R/M/F/H/V)</title>
  <link rel="preconnect" href="https://cdn.jsdelivr.net" />
  <style>
    :root{
      --bg:#0d0f12;
      --panel:#0f1115;
      --card:rgba(255,255,255,0.03);
      --muted:#9fdfff;
      --accent:linear-gradient(90deg,#00c3ff,#00ffa3);
      --glass:rgba(255,255,255,0.03);
      --radius:14px;
      --gap:16px;
      --fw-bold:800;
      --payload-color:#00e0ff;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:var(--bg);color:#eafcff;font-family:Inter,Segoe UI,Arial,sans-serif;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}
    .top-header{position:fixed;top:18px;left:18px;z-index:200;display:flex;align-items:center;gap:10px}
    .logo{height:52px;width:auto;cursor:pointer;transition:transform .18s ease}
    .logo:hover{transform:scale(1.04)}
    .container{max-width:1180px;margin:50px auto;padding:18px;display:grid;grid-template-columns:1fr 340px;gap:var(--gap);align-items:start}
    header{grid-column:1/-1;display:flex;flex-direction:column;align-items:center;gap:18px;margin-bottom:0}
    h1{margin:0;font-size:22px;font-weight:var(--fw-bold);text-align:center}
    .lead{font-size:13px;color:#9fdfff88;margin:0}
    .controls{display:flex;align-items:center;gap:14px;justify-content:center}
    .btn{padding:10px 14px;border-radius:12px;border:0;font-weight:700;cursor:pointer;background:var(--glass);color:#dffcff;backdrop-filter:blur(6px)}
    .btn.primary{background:var(--accent);color:#032022;box-shadow:0 6px 24px rgba(0,195,255,0.08),inset 0 -2px 0 rgba(0,0,0,0.12)}
    .status{background:var(--card);padding:8px 10px;border-radius:10px;color:var(--muted);font-weight:700;font-size:13px;margin:0 6px;min-width:220px;text-align:center}
    .video-wrap{background:#000;border-radius:var(--radius);overflow:hidden;min-height:380px;display:flex;flex-direction:column}
    .canvas-wrap{position:relative;width:100%;height:100%}
    canvas#output{display:block;width:100%;height:auto;background:#000}
    video#inputVideo{display:none}
    aside.panel{display:flex;flex-direction:column;gap:12px}
    .card{background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.015));padding:14px;border-radius:12px;border:1px solid rgba(255,255,255,0.02);box-shadow:0 6px 20px rgba(0,0,0,0.6)}
    /* Layout adjusted to match requested order:
       Row1: Left Eye | Right Eye
       Row2: Mouth    | Face Visible
       Row3: Horizontal | Vertical
    */
    .grid-stats{display:grid;grid-template-columns:repeat(2,1fr);gap:10px}
    .stat{background:rgba(255,255,255,0.02);padding:12px;border-radius:10px;font-weight:800;display:flex;flex-direction:column;gap:6px}
    .stat .label{font-size:12px;color:#bfefff}
    .stat .value{font-size:18px}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,monospace;color:var(--payload-color);word-break:break-word;font-size:20px;font-weight:800;text-align:center}
    .small{font-size:12px;color:#9fdfff88}
    @media(max-width:980px){
      .container{grid-template-columns:1fr;padding:14px}
      aside.panel{order:2}
    }
  </style>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
</head>
<body>
  <header class="top-header" aria-hidden="true">
    <img src="logo.png" alt="Robotic Schools Logo" class="logo">
  </header>

  <div class="container">
    <header>
      <h1>Face Detection and Tracking - Microbit + Arduino App</h1>

      <div style="height:8px"></div>

      <div class="controls" aria-hidden="false">
        <button id="connectArduinoBtn" class="btn primary" title="Connect / Disconnect Arduino">Connect Arduino</button>
        <div id="connStatus" class="status" role="status" aria-live="polite">Camera starting...</div>
        <button id="connectMicrobitBtn" class="btn primary" title="Connect / Disconnect micro:bit">Connect micro:bit</button>
      </div>
      <div style="height:6px"></div>
    </header>

    <main class="video-wrap" aria-label="Camera preview and face overlay">
      <div class="canvas-wrap">
        <canvas id="output" width="1280" height="720" aria-hidden="false"></canvas>
        <video id="inputVideo" autoplay playsinline muted></video>
      </div>
    </main>

    <aside class="panel" aria-label="Face status panel">
      <div class="card">
        <div style="font-weight:800;margin-bottom:8px">Detection</div>

        <div class="grid-stats">
          <!-- Row 1 -->
          <div class="stat frame">
            <div class="label">Left Eye</div>
            <div id="leftEye" class="value mono">—</div>
          </div>

          <div class="stat frame">
            <div class="label">Right Eye</div>
            <div id="rightEye" class="value mono">—</div>
          </div>

          <!-- Row 2 -->
          <div class="stat frame">
            <div class="label">Mouth</div>
            <div id="mouth" class="value mono">—</div>
          </div>

          <div class="stat frame">
            <div class="label">Face Visible</div>
            <div id="faceVisible" class="value mono">—</div>
          </div>

          <!-- Row 3 -->
          <div class="stat frame">
            <div class="label">Horizontal (H)</div>
            <div id="headH" class="value mono">—</div>
          </div>

          <div class="stat frame">
            <div class="label">Vertical (V)</div>
            <div id="headV" class="value mono">—</div>
          </div>
        </div>
      </div>

      <div class="card frame" style="margin-top:8px">
        <div style="font-weight:800;margin-bottom:8px">Sent to Device</div>
        <div id="lastPayload" class="mono">—</div>
      </div>

      <div class="card small">
        <div><strong>Notes:</strong></div>
        <ul style="margin:8px 0 0 16px;padding:0">
          <li>Use Chrome/Edge for Web Serial and Web Bluetooth support.</li>
        </ul>
      </div>
    </aside>
  </div>

  <script>
    // UI refs
    const canvas = document.getElementById('output');
    const videoEl = document.getElementById('inputVideo');
    const ctx = canvas.getContext('2d');
    const connectArduinoBtn = document.getElementById('connectArduinoBtn');
    const connectMicrobitBtn = document.getElementById('connectMicrobitBtn');
    const connStatus = document.getElementById('connStatus');

    const leftEyeEl = document.getElementById('leftEye');
    const rightEyeEl = document.getElementById('rightEye');
    const mouthEl = document.getElementById('mouth');
    const headVEl = document.getElementById('headV');
    const headHEl = document.getElementById('headH');
    const faceVisibleEl = document.getElementById('faceVisible');
    const lastPayloadEl = document.getElementById('lastPayload');

    const MIRROR_PREVIEW = true;

    // ---------- Web Serial (Arduino) ----------
    let port = null, writer = null, reader = null, serialConnected = false;
    const encoder = new TextEncoder();
    let writeQueue = Promise.resolve();
    function queueOp(op){ writeQueue = writeQueue.then(op, op); return writeQueue; }

    async function ensurePortOpen(requestIfMissing = true){
      if (!('serial' in navigator)) throw new Error('Web Serial not supported');
      if (port) {
        if (port.readable === false && port.writable === false) {
          try { await port.open({ baudRate: 115200 }); } catch(e){}
        }
        return port;
      }
      if (!requestIfMissing) throw new Error('No port available');
      const requested = await navigator.serial.requestPort();
      await requested.open({ baudRate: 115200 });
      port = requested;
      return port;
    }

    async function connectArduino(){
      if (serialConnected) { await disconnectArduino(); return; }
      try {
        connStatus.style.color = '';
        connStatus.textContent = 'Requesting port...';
        connectArduinoBtn.textContent = 'Requesting...';
        await ensurePortOpen(true);
        try {
          if (!port.readable || !port.writable) {
            await port.open({ baudRate: 115200 }).catch(()=>{});
          }
        } catch(e){}
        if (port.writable) {
          try { writer = port.writable.getWriter(); } catch(e){ writer = null; }
        } else {
          writer = null;
        }
        if (port.readable) {
          try { reader = port.readable.getReader(); readLoop().catch(()=>{}); } catch(e){ reader = null; }
        }
        serialConnected = true;
        connStatus.textContent = 'Connected to Arduino';
        connectArduinoBtn.textContent = 'Disconnect';
        updateButtonsVisibility();
      } catch (err) {
        serialConnected = false;
        connStatus.textContent = 'Not connected';
        connectArduinoBtn.textContent = 'Connect Arduino';
        console.error('Serial connect error', err);
        updateButtonsVisibility();
      }
    }

    async function disconnectArduino(){
      connectArduinoBtn.textContent = 'Disconnecting...';
      connStatus.textContent = 'Disconnecting...';
      try {
        if (reader) {
          await reader.cancel().catch(()=>{});
          try { reader.releaseLock(); } catch(e){}
          reader = null;
        }
      } catch(e){}
      try {
        if (writer) {
          try { await writer.close(); } catch(e){}
          try { writer.releaseLock(); } catch(e){}
          writer = null;
        }
      } catch(e){}
      try {
        if (port) {
          try { await port.close(); } catch(e){}
          port = null;
        }
      } catch(e){}
      serialConnected = false;
      connStatus.textContent = 'Not connected';
      connectArduinoBtn.textContent = 'Connect Arduino';
      updateButtonsVisibility();
    }

    async function readLoop(){
      if (!port || !port.readable) return;
      try {
        while (true) {
          const r = await reader.read();
          if (!r) break;
          const { value, done } = r;
          if (done) break;
        }
      } catch (e) {
      } finally {
        try { if (reader) { reader.releaseLock(); } } catch(e){}
        reader = null;
        if (serialConnected) {
          serialConnected = false;
          connStatus.textContent = 'Not connected';
          connectArduinoBtn.textContent = 'Connect Arduino';
          updateButtonsVisibility();
        }
      }
    }

    function sendSerialLine(line){
      if (!port) return;
      return queueOp(async () => {
        try {
          if (!writer && port.writable) {
            try { writer = port.writable.getWriter(); } catch(e){ writer = null; }
          }
          if (!writer) throw new Error('No writer');
          await writer.write(encoder.encode(line + '\n'));
        } catch (e) {
          console.warn('Serial write error', e);
          try {
            if (writer) { try { writer.releaseLock(); } catch(e){} writer = null; }
            if (port && port.readable === false && port.writable === false) {
              try { await port.close(); } catch(e){ }
              port = null;
              serialConnected = false;
              connStatus.textContent = 'Not connected';
              connectArduinoBtn.textContent = 'Connect Arduino';
              updateButtonsVisibility();
            }
          } catch(e){}
        }
      });
    }

    connectArduinoBtn.addEventListener('click', connectArduino);

    // ---------- Web Bluetooth (micro:bit, UART) ----------
    const UART_SERVICE_UUID = '6e400001-b5a3-f393-e0a9-e50e24dcca9e';
    const UART_NOTIFY_CHAR_UUID = '6e400002-b5a3-f393-e0a9-e50e24dcca9e';
    const UART_WRITE_CHAR_UUID  = '6e400003-b5a3-f393-e0a9-e50e24dcca9e';

    let bleDevice = null;
    let bleServer = null;
    let uartService = null;
    let notifyChar = null;
    let writeChar = null;
    let bleConnected = false;
    let bleWriteQueue = Promise.resolve();
    const MAX_RECONNECT_ATTEMPTS = 8;
    let reconnectAttempts = 0;

    function queueGattOperation(op){ bleWriteQueue = bleWriteQueue.then(op, op); return bleWriteQueue; }
    function safeLog(...args){ console.log('[BLE]', ...args); }

    async function connectMicrobit(){
      if (bleConnected) { await disconnectMicrobit(); return; }
      if (!('bluetooth' in navigator)) {
        alert('Web Bluetooth API not supported in this browser. Use Chrome/Edge on desktop or a supported mobile browser.');
        return;
      }
      try {
        connStatus.style.color = '';
        connStatus.style.display = '';
        connStatus.textContent = 'Requesting micro:bit...';
        connectMicrobitBtn.textContent = 'Requesting...';
        bleDevice = await navigator.bluetooth.requestDevice({
          filters: [{ namePrefix: 'BBC micro:bit' }],
          optionalServices: [UART_SERVICE_UUID]
        });
        if(!bleDevice) throw new Error('No device selected');
        bleDevice.addEventListener('gattserverdisconnected', handleDisconnected);
        connStatus.textContent = `Device: ${bleDevice.name || 'micro:bit'}`;
        connStatus.textContent = 'Connecting...';
        bleServer = await bleDevice.gatt.connect();
        connStatus.textContent = 'Getting UART service...';
        uartService = await bleServer.getPrimaryService(UART_SERVICE_UUID);
        connStatus.textContent = 'Getting characteristics...';
        writeChar = await uartService.getCharacteristic(UART_WRITE_CHAR_UUID).catch(()=>null);
        notifyChar = await uartService.getCharacteristic(UART_NOTIFY_CHAR_UUID).catch(()=>null);
        if(notifyChar && (notifyChar.properties.notify || notifyChar.properties.indicate)){
          await notifyChar.startNotifications();
          notifyChar.addEventListener('characteristicvaluechanged', onNotify);
        }
        bleConnected = true;
        reconnectAttempts = 0;
        connStatus.style.color = '';
        connStatus.textContent = `Connected: ${bleDevice.name || 'micro:bit'}`;
        connectMicrobitBtn.textContent = 'Disconnect';
        updateButtonsVisibility();
      } catch (err) {
        console.error('BLE connect failed', err);
        connStatus.textContent = 'micro:bit: connection failed';
        connStatus.style.color = '#ff6b6b';
        bleDevice = null;
        bleConnected = false;
        connectMicrobitBtn.textContent = 'Connect micro:bit';
        updateButtonsVisibility();
      }
    }

    async function disconnectMicrobit(){
      connectMicrobitBtn.textContent = 'Disconnecting...';
      try { if (notifyChar && notifyChar.stopNotifications) await notifyChar.stopNotifications(); } catch(e){}
      try { if (bleDevice && bleDevice.gatt && bleDevice.gatt.connected) bleDevice.gatt.disconnect(); } catch(e){}
      bleDevice = null; bleServer = null; writeChar = null; notifyChar = null;
      bleConnected = false;
      connectMicrobitBtn.textContent = 'Connect micro:bit';
      connStatus.textContent = serialConnected ? 'Connected to Arduino' : 'Not connected';
      connStatus.style.display = '';
      updateButtonsVisibility();
    }

    function handleDisconnected(event){
      const dev = event.target;
      safeLog(`Device ${dev && dev.name} disconnected`);
      bleConnected = false;
      connStatus.textContent = 'Disconnected — attempting reconnect...';
      connStatus.style.color = '#ffcc66';
      attemptReconnect();
    }

    function attemptReconnect(){
      if(!bleDevice){
        connStatus.textContent = 'Not connected';
        connectMicrobitBtn.textContent = 'Connect micro:bit';
        connStatus.style.display = '';
        updateButtonsVisibility();
        return;
      }
      reconnectAttempts++;
      if(reconnectAttempts > MAX_RECONNECT_ATTEMPTS){
        connStatus.textContent = 'Reconnect failed — click Connect';
        connectMicrobitBtn.textContent = 'Connect micro:bit';
        connStatus.style.color = '#ff6b6b';
        bleDevice = null;
        bleConnected = false;
        updateButtonsVisibility();
        return;
      }
      const backoffMs = Math.min(1000 * Math.pow(2, reconnectAttempts-1), 20000);
      safeLog('Reconnect attempt', reconnectAttempts, 'next in ms', backoffMs);
      setTimeout(async () => {
        try {
          connStatus.textContent = `Reconnect attempt ${reconnectAttempts}...`;
          bleServer = await bleDevice.gatt.connect();
          uartService = await bleServer.getPrimaryService(UART_SERVICE_UUID);
          writeChar = await uartService.getCharacteristic(UART_WRITE_CHAR_UUID).catch(()=>null);
          notifyChar = await uartService.getCharacteristic(UART_NOTIFY_CHAR_UUID).catch(()=>null);
          if(notifyChar && (notifyChar.properties.notify || notifyChar.properties.indicate)){
            await notifyChar.startNotifications();
            notifyChar.addEventListener('characteristicvaluechanged', onNotify);
          }
          bleConnected = true;
          reconnectAttempts = 0;
          connStatus.style.color = '';
          connStatus.textContent = `Reconnected: ${bleDevice.name || 'micro:bit'}`;
          connectMicrobitBtn.textContent = 'Disconnect';
          updateButtonsVisibility();
        } catch(e){
          console.warn('Reconnect attempt failed', e);
          attemptReconnect();
        }
      }, backoffMs);
    }

    function onNotify(ev){
      const value = ev.target.value;
      const text = new TextDecoder().decode(value);
      safeLog('Notified:', text);
    }

    function sendUARTRaw(bytes){
      if(!writeChar){
        safeLog('No write characteristic - cannot send');
        connStatus.textContent = 'Not writable - reconnect or check micro:bit firmware';
        connStatus.style.color = '#ff6b6b';
        return Promise.reject(new Error('No write characteristic'));
      }
      return queueGattOperation(async () => {
        try {
          if(typeof writeChar.writeValue === 'function'){
            await writeChar.writeValue(bytes);
          } else if(typeof writeChar.writeValueWithoutResponse === 'function'){
            await writeChar.writeValueWithoutResponse(bytes);
          } else {
            if(writeChar.properties && writeChar.properties.writeWithoutResponse && typeof writeChar.writeValue === 'function'){
              await writeChar.writeValue(bytes);
            } else {
              throw new Error('No writable method on characteristic');
            }
          }
          safeLog('Sent bytes', bytes);
        } catch (err){
          console.error('Write failed', err);
          throw err;
        }
      });
    }

    async function sendToMicrobit(text){
      if(!bleConnected || !writeChar){
        safeLog('Skipped send - not connected or writable');
        return;
      }
      try {
        const payload = encoder.encode(String(text) + '\n');
        await sendUARTRaw(payload);
      } catch(e){
        console.error('sendToMicrobit error', e);
      }
    }

    connectMicrobitBtn.addEventListener('click', connectMicrobit);

    // keep buttons visible state consistent
    function updateButtonsVisibility(){
      if (serialConnected) {
        connectMicrobitBtn.style.display = 'none';
        connectArduinoBtn.style.display = '';
        connStatus.style.display = '';
      } else if (bleConnected) {
        connectArduinoBtn.style.display = 'none';
        connectMicrobitBtn.style.display = '';
        connStatus.style.display = '';
      } else {
        connectMicrobitBtn.style.display = '';
        connectArduinoBtn.style.display = '';
        connStatus.style.display = '';
      }
    }

    // ---------- MediaPipe FaceMesh ----------
    const faceMesh = new FaceMesh({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
    });

    faceMesh.setOptions({
      maxNumFaces: 1,
      refineLandmarks: true,
      minDetectionConfidence: 0.6,
      minTrackingConfidence: 0.5
    });

    faceMesh.onResults(onResults);

    // Start camera; canvas internal size already 1280x720
    let camera = new Camera(videoEl, {
      onFrame: async () => { await faceMesh.send({ image: videoEl }); },
      width: 1280,
      height: 720,
      facingMode: 'user'
    });

    camera.start().then(() => {
      connStatus.textContent = 'Not connected / Camera ready';
      updateButtonsVisibility();
    }).catch((e) => {
      console.error('Camera start failed', e);
      connStatus.textContent = 'Camera unavailable';
    });

    // ---------- helpers & indices ----------
    const RIGHT_EYE_IDX = [33,159,158,133,153,145];
    const LEFT_EYE_IDX  = [362,380,374,263,386,385];
    const MOUTH_TOP = 13;
    const MOUTH_BOTTOM = 14;
    const MOUTH_LEFT = 78;
    const MOUTH_RIGHT = 308;
    const NOSE_TIP = 1;

    const dist = (a,b) => Math.hypot(a.x - b.x, a.y - b.y);

    function eyeRatio(landmarks, idxs){
      const p0 = landmarks[idxs[0]], p1 = landmarks[idxs[1]], p2 = landmarks[idxs[2]];
      const p3 = landmarks[idxs[3]], p4 = landmarks[idxs[4]], p5 = landmarks[idxs[5]];
      const vert = (dist(p1,p4) + dist(p2,p5)) / 2;
      const hor = dist(p0,p3);
      return hor === 0 ? 0 : vert / hor;
    }
    function mouthRatio(landmarks){
      const top = landmarks[MOUTH_TOP], bottom = landmarks[MOUTH_BOTTOM];
      const left = landmarks[MOUTH_LEFT], right = landmarks[MOUTH_RIGHT];
      const vert = dist(top,bottom);
      const hor = dist(left,right);
      return hor === 0 ? 0 : vert / hor;
    }

    // thresholds (in normalized coordinates). increased so micro-movements don't flip states.
    const EYE_OPEN_THRESHOLD = 0.22;
    const MOUTH_OPEN_THRESHOLD = 0.28;
    const HEAD_X_THRESHOLD = 0.06; // horizontal threshold
    const HEAD_Y_THRESHOLD = 0.06; // vertical threshold

    // smoothing & hysteresis settings
    const EMA_ALPHA = 0.12;    // nose smoothing (higher = more responsive; lower = smoother)
    const BASELINE_ADAPT_ALPHA = 0.0025; // very slow baseline adaptation (prevents long-term drift)
    const STABLE_FRAMES_REQUIRED = 3; // consecutive frames required to accept new H/V direction

    let baseline = null;
    let smoothedNose = null;

    // stability counters for hysteresis
    let headH_candidate = 0; // -1,0,1 candidate direction
    let headV_candidate = 0;
    let headH_counter = 0;
    let headV_counter = 0;
    let currentHeadH = 0;
    let currentHeadV = 0;

    // draw mask visuals
    function drawMaskExact(landmarks){
      drawConnectors(ctx, landmarks, FACEMESH_TESSELATION, {color: 'rgba(255,255,255,0.3)', lineWidth: 1});
      drawConnectors(ctx, landmarks, FACEMESH_RIGHT_EYE, {color: '#00E0FF', lineWidth: 2});
      drawConnectors(ctx, landmarks, FACEMESH_RIGHT_EYEBROW, {color: '#FFD500', lineWidth: 2});
      drawConnectors(ctx, landmarks, FACEMESH_LEFT_EYE, {color: '#00E0FF', lineWidth: 2});
      drawConnectors(ctx, landmarks, FACEMESH_LEFT_EYEBROW, {color: '#FFD500', lineWidth: 2});
      drawConnectors(ctx, landmarks, FACEMESH_FACE_OVAL, {color: '#FFFFFF', lineWidth: 2});
      drawConnectors(ctx, landmarks, FACEMESH_LIPS, {color: '#FF6347', lineWidth: 2});
    }

    // ---------- main results callback ----------
    let lastSent = '';
    function onResults(results){
      // Draw video + mask overlay
      ctx.save();
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      if (MIRROR_PREVIEW){
        ctx.translate(canvas.width, 0);
        ctx.scale(-1, 1);
      }

      ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);

      if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0){
        for (const landmarks of results.multiFaceLandmarks){
          drawMaskExact(landmarks);
        }
      }

      ctx.restore();

      // Detection stats and payload
      const hasFace = !!(results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0);
      if (!hasFace){
        leftEyeEl.textContent = '—';
        rightEyeEl.textContent = '—';
        mouthEl.textContent = '—';
        headVEl.textContent = '—';
        headHEl.textContent = '—';
        faceVisibleEl.textContent = 0;
        lastPayloadEl.textContent = '—';
        lastSent = '';
        baseline = null; smoothedNose = null;
        headH_candidate = headV_candidate = 0;
        headH_counter = headV_counter = 0;
        currentHeadH = currentHeadV = 0;
        return;
      }

      const landmarks = results.multiFaceLandmarks[0];

      // compute ratios
      const rRatio = eyeRatio(landmarks, RIGHT_EYE_IDX);
      const lRatio = eyeRatio(landmarks, LEFT_EYE_IDX);
      const mRatio = mouthRatio(landmarks);

      const rightEyeState = rRatio > EYE_OPEN_THRESHOLD ? 1 : 0;
      const leftEyeState  = lRatio > EYE_OPEN_THRESHOLD ? 1 : 0;
      const mouthState    = mRatio > MOUTH_OPEN_THRESHOLD ? 1 : 0;

      // nose smoothing & baseline
      const nose = landmarks[NOSE_TIP];
      if (!smoothedNose) {
        smoothedNose = { x: nose.x, y: nose.y };
      } else {
        smoothedNose.x += (nose.x - smoothedNose.x) * EMA_ALPHA;
        smoothedNose.y += (nose.y - smoothedNose.y) * EMA_ALPHA;
      }

      if (!baseline) {
        baseline = { x: smoothedNose.x, y: smoothedNose.y };
      } else {
        baseline.x += (smoothedNose.x - baseline.x) * BASELINE_ADAPT_ALPHA;
        baseline.y += (smoothedNose.y - baseline.y) * BASELINE_ADAPT_ALPHA;
      }

      const dx = smoothedNose.x - baseline.x;
      const dy = smoothedNose.y - baseline.y;

      // candidate directions
      let candidateH = 0;
      if (dx < -HEAD_X_THRESHOLD) candidateH = -1;
      else if (dx > HEAD_X_THRESHOLD) candidateH = 1;
      else candidateH = 0;

      let candidateV = 0;
      if (dy < -HEAD_Y_THRESHOLD) candidateV = -1;
      else if (dy > HEAD_Y_THRESHOLD) candidateV = 1;
      else candidateV = 0;

      // hysteresis
      if (candidateH === headH_candidate) {
        headH_counter = Math.min(headH_counter + 1, STABLE_FRAMES_REQUIRED);
      } else {
        headH_candidate = candidateH;
        headH_counter = 1;
      }
      if (candidateV === headV_candidate) {
        headV_counter = Math.min(headV_counter + 1, STABLE_FRAMES_REQUIRED);
      } else {
        headV_candidate = candidateV;
        headV_counter = 1;
      }

      if (headH_counter >= STABLE_FRAMES_REQUIRED && currentHeadH !== headH_candidate) {
        currentHeadH = headH_candidate;
      }
      if (headV_counter >= STABLE_FRAMES_REQUIRED && currentHeadV !== headV_candidate) {
        currentHeadV = headV_candidate;
      }

      // update UI
      leftEyeEl.textContent = leftEyeState;
      rightEyeEl.textContent = rightEyeState;
      mouthEl.textContent = mouthState;
      faceVisibleEl.textContent = 1;
      headHEl.textContent = currentHeadH;
      headVEl.textContent = currentHeadV;

      // payload order: L,R,M,F,H,V
      const faceVisible = 1;
      const payload = `L${leftEyeState},R${rightEyeState},M${mouthState},F${faceVisible},H${currentHeadH},V${currentHeadV}`;
      if (payload !== lastSent){
        lastSent = payload;
        lastPayloadEl.textContent = payload;
        if (serialConnected) {
          sendSerialLine(payload);
        } else if (bleConnected) {
          sendToMicrobit(payload).catch(e=>console.warn('BLE send failed', e));
        }
      }
    }

    // cleanup on unload
    window.addEventListener('beforeunload', async () => {
      try {
        if (reader) { await reader.cancel().catch(()=>{}); try { reader.releaseLock(); } catch(e){} reader = null; }
      } catch(e){}
      try { if (writer) { try { await writer.close(); } catch(e){} try { writer.releaseLock(); } catch(e){} writer = null; } } catch(e){}
      try { if (port) { try { await port.close(); } catch(e){} port = null; } } catch(e){}
      try { if (notifyChar && notifyChar.stopNotifications) await notifyChar.stopNotifications(); } catch(e){}
      try { if (bleDevice && bleDevice.gatt && bleDevice.gatt.connected) bleDevice.gatt.disconnect(); } catch(e){}
    });

    // state monitor
    const stateMonitorInterval = setInterval(() => {
      if (bleDevice && bleDevice.gatt) {
        const nowBle = !!bleDevice.gatt.connected;
        if (nowBle !== bleConnected) {
          bleConnected = nowBle;
          connStatus.style.display = bleConnected ? '' : '';
          connStatus.textContent = bleConnected ? `Connected: ${bleDevice.name || 'micro:bit'}` : 'Not connected';
          connectMicrobitBtn.textContent = bleConnected ? 'Disconnect' : 'Connect micro:bit';
          updateButtonsVisibility();
        }
      }
      if (port) {
        const writable = !!port.writable;
        const readable = !!port.readable;
        const nowSerial = writable || readable || serialConnected;
        if (!nowSerial && serialConnected) {
          serialConnected = false;
        }
      }
      if (serialConnected) {
        connStatus.style.display = '';
        connStatus.textContent = 'Connected to Arduino';
        connectArduinoBtn.textContent = 'Disconnect';
      } else {
        if (!bleConnected) {
          connStatus.style.display = '';
          connStatus.textContent = 'Not connected';
        }
        connectArduinoBtn.textContent = 'Connect Arduino';
      }
      updateButtonsVisibility();
    }, 1500);
  </script>
</body>
</html>
